<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CommonJS规范</title>
    <url>/2020/04/21/CommonJS%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p><strong><code>CommonJS</code>是一种规范，通过简单的API声明服务器的模块，目标是让<code>JavaScript</code>可以运行在浏览器之外的所有地方，例如在服务器或者本地桌面应用服务程序上。</strong><br>这个项目最开始是由 Mozilla 的工程师 Kevin Dangoor 在2009年1月创建的，当时的名字是 <code>ServerJS</code>。</p>
<blockquote>
<p>我在这里描述的并不是一个技术问题，而是一件重大的事情，让大家走到一起来做决定，迈出第一步，来建立一个更大更酷的东西。 —— Kevin Dangoor’s What Server Side JavaScript needs</p>
</blockquote>
<p><code>CommonJS</code> 规范是为了解决 <code>JavaScript</code> 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行。该规范的主要内容是，模块必须通过 <code>module.exports</code> 或 <code>exports</code> 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。</p>
<h3 id="CommonJS与NodeJS的关系"><a href="#CommonJS与NodeJS的关系" class="headerlink" title="CommonJS与NodeJS的关系"></a>CommonJS与NodeJS的关系</h3><p><code>Node.js</code>借鉴<code>CommonJS</code>模块规范实现了一套非常易用的模块系统，<code>npm</code>对模块规范的完美支持，也使得<code>Node.js</code>应用开发事半功倍，但是经常有人会说<code>NodeJS</code>是基于<code>CommonJS</code>规范的，那其实这里有两个误区：</p>
<ul>
<li>并不是先有的规范再有的<code>NodeJS</code>：虽然<code>CommonJS</code>在<code>NodeJS</code>之后产生，但是它对<code>NodeJS</code>后续发展影响甚大，所以说<code>NodeJS</code>基于<code>CommonJS</code>只是强调了<code>CommonJS</code>的重要性，而不是时间上的具体区分。</li>
<li><code>NodeJS</code>并不支持所有<code>CommonJS</code>规范：<code>CommonJS</code>是一个很大的项目，里面制定了一系列的规范，Node并没有在所有方面都依赖<code>CommonJS</code>，只是在模块方面遵循了<code>CommonJS</code>当中的模块规范。</li>
</ul>
<h3 id="CommonJS的规范与NodeJS实现上面的区别"><a href="#CommonJS的规范与NodeJS实现上面的区别" class="headerlink" title="CommonJS的规范与NodeJS实现上面的区别"></a>CommonJS的规范与NodeJS实现上面的区别</h3><p>具体区别：</p>
<ul>
<li>原生<code>Node.js</code>当中，<code>module.exports</code>是真正的特殊对象，也是真正的对外暴露接口，在<code>CommonJS</code>没有出现以前，也没有<code>exports</code>这种东西。</li>
<li>在<code>CommonJS</code>规范当中,规定<code>exports</code>对象是暴露接口的对象，所以<code>NodeJS</code>为了遵循规定但是又不修改自身<code>module.exports</code>的基础上，额外增加了将<code>exports</code>关键字绑定到了<code>module.exports</code>对象上的默认操作，说白了就<code>exports</code>默认指向了<code>module.exports</code>导出的对象。这就是为什么<code>NodeJS</code>在包装模块的时候将<code>exports</code>作为参数的原因，默认将规范添加了进来。</li>
<li>两者同时存在时，以<code>module.exports</code>为准，因<code>为module.exports</code>的实际含义是一个完全预先构造的对象，但是<code>exports</code>可以手动被我们篡改指向，这就是很多讲师在给<code>NodeJS</code>初学者解释两者区别最常用的一句话：<code>exports</code>在没有改变指向的时候是<code>module.exports</code>的代替品 。</li>
</ul>
<h2 id="CommonJS的核心"><a href="#CommonJS的核心" class="headerlink" title="CommonJS的核心"></a>CommonJS的核心</h2><p><code>Node.js</code>对模块定义的非常简单，主要分为<code>模块引用</code>、<code>模块定义</code>、<code>模块标识</code>，其中最常用的模块处理命令就有两个：<code>require</code> 和 <code>exports</code>。</p>
<h3 id="模块的引入和导出"><a href="#模块的引入和导出" class="headerlink" title="模块的引入和导出"></a>模块的引入和导出</h3><p>模块可以理解为将能够完成实现一个独立功能的代码封装到一个代码单元当中，在 <code>NodeJS</code> 中创建一个模块可以理解为把全部和此功能关联的函数放在一个文件当中。</p>
<p>我们之前就说<code>exports</code>默认情况下是<code>module.exports</code>的引用，所以使用方面只有更方便的说法，没有对错和性能方面的区分。</p>
<ul>
<li><p>当我们编写对外暴露对个API的工具我们可以使用<code>exports</code>更方便</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exports的写法</span></span><br><span class="line"> exports.add = <span class="keyword">async</span>() =&gt; &#123; &#125;;</span><br><span class="line"> exports.sub = <span class="keyword">async</span>() =&gt; &#123; &#125;;</span><br><span class="line"> <span class="comment">// 外部引用和使用</span></span><br><span class="line"> <span class="keyword">const</span> add = <span class="built_in">require</span>(<span class="string">'./xxx.js'</span>);</span><br><span class="line"> <span class="keyword">let</span> result = add();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// module.exports的写法</span></span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"> <span class="built_in">module</span>.exports = &#123; add, sub &#125;;</span><br><span class="line"> <span class="comment">// 外部引用和使用</span></span><br><span class="line"> <span class="keyword">const</span> obj = <span class="built_in">require</span>(<span class="string">'./xxx.js'</span>);</span><br><span class="line"> <span class="keyword">let</span> result = obj.add();</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们编写同一个对象的时候使用<code>module.exports</code>更方便</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    study: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) =&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'I have finished my homework'</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Student(<span class="string">'小明'</span>);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="模块间的循环引用"><a href="#模块间的循环引用" class="headerlink" title="模块间的循环引用"></a>模块间的循环引用</h3><p>不管在<code>NodeJS</code>当中还是别的地方，模块之间都会相互引用，官网称之为<code>module cycles</code>，翻译成为模块间的循环引用。<br>而在<code>CommonJS Moudules1.0</code>当中有说明，在这种情况下，<code>require</code>返回的对象必须至少包含此外部模块在调用<code>require</code>函数之前就已经准备完毕的输出，这种解决模块间的循环引用的策略称为<code>模块缓存策略</code>。<br>A模块引用了B模块，B模块也引用了A模块，这种循环引用遵循的规则是这样：<code>一旦出现某个模块被循环加载，就只输出已经执行的部分，还未执行的部分不会输出。</code></p>
<h3 id="模块的缓存"><a href="#模块的缓存" class="headerlink" title="模块的缓存"></a>模块的缓存</h3><p><code>CommonJS</code>用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。<br><code>CommonJS</code>会对加载好的模块进行缓存，也就是说同一模块只会加载一次。<code>NodeJS</code>的源码过于复杂，我们可以通过webpack进行代码打包来验证这也一点。<br><img src="/2020/04/21/CommonJS%E8%A7%84%E8%8C%83/1.png" alt="CommonJS的缓存机制"><br>我们不难发现，通过<code>__webpack_require__</code>引入其他模块的时候会检查之前是否引入过，如果引入过，那么就使用缓存。</p>
<h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><h3 id="CommonJS模块是运行时加载，ES6模块是编译时输出接口"><a href="#CommonJS模块是运行时加载，ES6模块是编译时输出接口" class="headerlink" title="CommonJS模块是运行时加载，ES6模块是编译时输出接口"></a>CommonJS模块是运行时加载，ES6模块是编译时输出接口</h3><ul>
<li><p>运行时加载: <code>CommonJS</code> 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</p>
</li>
<li><p>编译时加载: <code>ES6 模块</code> 不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</p>
<p>PS: ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>
</li>
</ul>
<h3 id="CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用"><a href="#CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用" class="headerlink" title="CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用"></a>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</h3><ul>
<li><code>CommonJS</code>模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>
<li><code>ES6模块</code>的运行机制与<code>CommonJS</code>不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，<code>ES6</code>的<code>import</code>有点像<code>Unix</code>系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，<code>ES6</code> 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************** a.js**********************/</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>          <span class="comment">// count是个普通值</span></span><br><span class="line">exports.count = count; <span class="comment">// 输出值（值得类型时普通值）的拷贝</span></span><br><span class="line">exports.add = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    count++;           <span class="comment">//这里改变count值，并不会将module.exports对象的count属性值改变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************** b.js**********************/</span></span><br><span class="line"><span class="keyword">const</span> &#123; count, add &#125; = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count)     <span class="comment">// 0</span></span><br><span class="line">add();</span><br><span class="line"><span class="built_in">console</span>.log(count)     <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************** c.js**********************/</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj.count)     <span class="comment">// 0</span></span><br><span class="line">obj.add();</span><br><span class="line"><span class="built_in">console</span>.log(obj.count)     <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>有些小伙伴会疑惑为啥不同的引用写法会造成不同，c.js很好理解，因为obj这个变量存的和a.js导出对象一样的堆中地址，所以操作是相互影响的，但是b.js这种解构写法类似于下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="keyword">const</span> count = obj.count</span><br><span class="line"><span class="keyword">const</span> add = obj.add</span><br><span class="line"><span class="built_in">console</span>.log(obj.count)     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(count)         <span class="comment">// 0</span></span><br><span class="line">add();</span><br><span class="line"><span class="built_in">console</span>.log(obj.count)     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(count)         <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>显然这里count虽然和obj.count的值一样，但是add操作的是obj里面的count,外面的count是不会受影响的。那我们再来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************** a.js**********************/</span></span><br><span class="line"><span class="keyword">let</span> count = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125; <span class="comment">// count是个引用值类型</span></span><br><span class="line">exports.count = count  <span class="comment">// 输出值（值得类型是引用值）的拷贝</span></span><br><span class="line">exports.add = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    count.num++;       <span class="comment">// 这里改变count中属性值，会将module.exports对象的count属性改变</span></span><br><span class="line">    count = &#123;&#125;         <span class="comment">// 这里改变了引用也不会改变已经导出出的那个count的引用值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************** b.js**********************/</span></span><br><span class="line"><span class="keyword">const</span> &#123; count, add &#125; = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count)     <span class="comment">//&#123; num: 0 &#125;</span></span><br><span class="line">add();</span><br><span class="line"><span class="built_in">console</span>.log(count)     <span class="comment">//&#123; num: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>上述第二种情况可能会让你感到疑惑，你不是说值得拷贝么，一旦输出一个值，模块内部的变化就影响不到这个值么？怎么代码表现出来是会影响呢？我们来看一张图就明白了<br><img src="/2020/04/21/CommonJS%E8%A7%84%E8%8C%83/2.png" alt="CommonJS的缓存机制"></p>
<p>虽然count是一个引用，但是0x005这地址本身就是个普通值，所以拷贝到b.js当中依旧是0x005这个普通值，只不过两个0x005指向堆中相同的内存，就好比两把钥匙能开同一扇们一样,所以值得拷贝这句话没有错。<br>外部模块a.js中的count = {}表示外部模块当中的变化，由0x005变成了0x006，但是也没有影响到在b.js当中缓存值count的指向，这个缓存值依旧是0x005,所以 一旦输出一个值，模块内部的变化就影响不到这个值 这句话也没有问题。</p>
<p>ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************** a.js**********************/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> count = <span class="number">0</span>;<span class="comment">//输出的是值的引用，指向同一块内存</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    count++;<span class="comment">//此时引用指向的内存值发生改变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************** b.js**********************/</span></span><br><span class="line"><span class="keyword">import</span> &#123; count, add &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">//0</span></span><br><span class="line">add();</span><br><span class="line"><span class="built_in">console</span>.log(count)<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS·基础篇</tag>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS与RPC</title>
    <url>/2020/04/24/NodeJS%E4%B8%8ERPC/</url>
    <content><![CDATA[<h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p><code>RPC（Remote Procedure Call）</code>中文名「远程过程调用」，又是一个很蹩脚的翻译。我们拆开理解下，「过程」也叫方法或函数，「远程」就是说方法不在当前进程里，而是在其他进程或机器上面，合起来 RPC 就是调用其他进程或机器上面的函数。</p>
<h3 id="为什么要进行RPC"><a href="#为什么要进行RPC" class="headerlink" title="为什么要进行RPC"></a>为什么要进行RPC</h3><p>在没有网络的时代，程序都是单机版的，所有逻辑都必须在同一个进程里。进程之间就像高楼大厦里面陌生的邻居，大家无法共享，遇到同样的功能只能重复实现一次。显然进程的障碍是逆天的，不符合先进生产力的发展方向，这个时候「进程间通信」的需求出现了，大家要求进程之间能够相互交流，相互共享和调用。这样再写程序，就可以利用进程间通信机制来调用和共享已经存在的功能了。随着网络的出现，进程的隔阂进一步消除，不光同一栋楼里的邻居可以共享资源，其他小区、甚至其他城市的居民都可以通过互联网互相调用，这就是 <code>RPC</code>。</p>
<h3 id="如何理解RPC-RPC的原理"><a href="#如何理解RPC-RPC的原理" class="headerlink" title="如何理解RPC(RPC的原理)"></a>如何理解RPC(RPC的原理)</h3><p><code>RPC</code>就是要像调用本地的函数一样去调远程函数, 在研究<code>RPC</code>前，我们先看看本地调用是怎么调的。</p>
<h4 id="本地过程调用"><a href="#本地过程调用" class="headerlink" title="本地过程调用"></a>本地过程调用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>对于以上代码，我们都非常熟悉，这里有俩个非常关键的点</p>
<ul>
<li>如何调用add函数（换句话说如何找到add函数）</li>
<li>如何将参数传递过去，并且取到返回值</li>
</ul>
<h4 id="RPC调用"><a href="#RPC调用" class="headerlink" title="RPC调用"></a>RPC调用</h4><p>在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，<code>add</code>是在另一个进程中执行的。<br>没错，上面俩个关键的点就<code>RPC</code>需要解决的问题。</p>
<ul>
<li><strong>Call ID映射</strong><br>我们怎么告诉远程机器我们要调用<code>add</code>，而不是其他函数呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用<code>add</code>，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在<code>RPC</code>中，所有的函数都必须有自己的一个<code>ID</code>。这个<code>ID</code>在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个<code>ID</code>。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; <code>Call ID</code>} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的<code>Call ID</code>必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的<code>Call ID</code>，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</li>
<li><strong>序列化和反序列化</strong><br>客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用<code>C++</code>，客户端用<code>Java或者Python</code>）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</li>
<li><strong>网络传输</strong><br>远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把<code>Call ID</code>和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分<code>RPC</code>框架都使用<code>TCP</code>协议，但其实<code>UDP</code>也可以，而<code>gRPC</code>干脆就用了<code>HTTP2</code>。</li>
</ul>
<p>好了，我们简述一下一个RPC的调用过程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client端 </span></span><br><span class="line"><span class="comment">//    int l_times_r = Call(ServerAddr, Multiply, lvalue, rvalue)</span></span><br><span class="line"><span class="number">1.</span> 将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法</span><br><span class="line"><span class="number">2.</span> 将Call ID，参数序列化。可以直接将它们的值以二进制形式打包</span><br><span class="line"><span class="number">3.</span> 把<span class="number">2</span>中得到的数据包发送给Server，这需要使用网络传输层</span><br><span class="line"><span class="number">4.</span> 等待服务器返回结果</span><br><span class="line"><span class="number">5.</span> 如果服务器调用成功，那么就将结果反序列化</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server端</span></span><br><span class="line"><span class="number">1.</span> 在本地维护一个Call ID到函数引用的映射call_id_map，可以用map来实现</span><br><span class="line"><span class="number">2.</span> 等待请求</span><br><span class="line"><span class="number">3.</span> 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class="line"><span class="number">4.</span> 通过在call_id_map中查找，得到相应的函数引用</span><br><span class="line"><span class="number">5.</span> 将参数反序列化后，在本地调用函数，得到结果</span><br><span class="line"><span class="number">6.</span> 将结果序列化后通过网络返回给Client</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/24/NodeJS%E4%B8%8ERPC/1.png" alt="RPC"></p>
<h3 id="NodeJS与RPC"><a href="#NodeJS与RPC" class="headerlink" title="NodeJS与RPC"></a>NodeJS与RPC</h3><h4 id="数据的序列化与反序列化"><a href="#数据的序列化与反序列化" class="headerlink" title="数据的序列化与反序列化"></a>数据的序列化与反序列化</h4><p>前端工程师对<code>http</code>协议肯定都非常熟悉，我们一直都在和它打交道。因为<code>http</code>协议是文本协议，所以我们在<code>http</code>协议中使用的数据格式一般都是文本如: <code>text/html</code>, <code>JSON</code>等。<br>在<code>RPC</code>中，我们得使用二进制数据来进行传输，原因有俩点</p>
<ul>
<li>更小的数据体积</li>
<li>更快的编解码速率</li>
</ul>
<p>下面我介绍一种二进制数据的序列化与反序列化工具 <code>protocol-buffers</code> <a href="https://www.npmjs.com/package/protocol-buffers" target="_blank" rel="noopener">protocol-buffers</a>。</p>
<p>我们建一个<code>test.proto</code>文件，然后在里面定义数据格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message Test &#123;</span><br><span class="line">  required float num  &#x3D; 1;</span><br><span class="line">  required string payload &#x3D; &#39;2&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NodeJS</code>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> protobuf = <span class="built_in">require</span>(<span class="string">'protocol-buffers'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = protobuf(fs.readFileSync(path.join(__dirname, <span class="string">'./test.proto'</span>), <span class="string">'utf-8'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf = messages.Test.encode(&#123;</span><br><span class="line">    num: <span class="number">42</span>,</span><br><span class="line">    payload: <span class="string">'hello world'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'数据序列化'</span>, buf);</span><br><span class="line"><span class="comment">//数据序列化 &lt;Buffer 0d 00 00 28 42 12 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'数据反序列化'</span>, messages.Test.decode(buf))</span><br><span class="line"><span class="comment">//数据反序列化 &#123; num: 42, payload: 'hello world' &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过上面的简单代码我们对数据进行序列化与反序列化，更多详情可以看 <a href="https://www.npmjs.com/package/protocol-buffers" target="_blank" rel="noopener">protocol-buffers</a> 文档。</p>
<h4 id="NodeJS-net模块建立TCP通道"><a href="#NodeJS-net模块建立TCP通道" class="headerlink" title="NodeJS net模块建立TCP通道"></a>NodeJS net模块建立TCP通道</h4><p><code>server.js</code>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">    socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(buffer.toString());</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3001</span>);</span><br><span class="line"><span class="comment">//在本地3001端口启动服务</span></span><br></pre></td></tr></table></figure>
<p><code>client.js</code>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> net.Socket(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">client.connect(&#123;</span><br><span class="line">    port: <span class="number">3001</span>,</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.write(<span class="string">'TCP 建立'</span>);</span><br></pre></td></tr></table></figure>
<p>一旦我们连接<code>server.js</code>启动的服务，服务端就输出客户端传递过去的<code>TCP 建立</code>文字。</p>
<h4 id="NodeJS简单演示RPC"><a href="#NodeJS简单演示RPC" class="headerlink" title="NodeJS简单演示RPC"></a>NodeJS简单演示RPC</h4><p>话不多说，直接上代码</p>
<p><code>test.protp</code>数据格式定义: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message Test &#123;</span><br><span class="line">  required string key  &#x3D; 1;</span><br><span class="line">  required string handleId &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Resp &#123;</span><br><span class="line">    required string result &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>client.js</code>代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> protobuf = <span class="built_in">require</span>(<span class="string">'protocol-buffers'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> net.Socket(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//call Id</span></span><br><span class="line"><span class="keyword">const</span> handleMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">handleMap.set(<span class="string">'find'</span>, <span class="string">'node_rpc_handle_fun_id_1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="keyword">const</span> params = [<span class="string">'111'</span>, <span class="string">'222'</span>, <span class="string">'333'</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据处理</span></span><br><span class="line"><span class="keyword">const</span> messages = protobuf(fs.readFileSync(path.join(__dirname, <span class="string">'./test.proto'</span>), <span class="string">'utf-8'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client.connect(&#123;</span><br><span class="line">    port: <span class="number">3001</span>,</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">params.forEach(<span class="function">(<span class="params">param, i</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = &#123;</span><br><span class="line">            key: param,</span><br><span class="line">            handleId: handleMap.get(<span class="string">'find'</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//数据的序列化</span></span><br><span class="line">        <span class="keyword">const</span> buf = messages.Test.encode(data);</span><br><span class="line">        <span class="comment">//网络传输</span></span><br><span class="line">        client.write(buf);</span><br><span class="line">    &#125;, i * <span class="number">100</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//返回结果反序列化</span></span><br><span class="line">    <span class="keyword">const</span> data = messages.Resp.decode(buffer);</span><br><span class="line">    <span class="built_in">console</span>.log(data.result);</span><br><span class="line">    <span class="comment">//NodeJS</span></span><br><span class="line">    <span class="comment">//React</span></span><br><span class="line">    <span class="comment">//Webpack</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>三个重要操作</p>
<ul>
<li>读取<code>Call Id</code>,参数</li>
<li>数据序列化与反序列化</li>
<li>与<code>server</code>建立网络连接</li>
</ul>
<p><code>server.js</code>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> protobuf = <span class="built_in">require</span>(<span class="string">'protocol-buffers'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据源</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="string">'111'</span>: <span class="string">'NodeJS'</span>,</span><br><span class="line">    <span class="string">'222'</span>: <span class="string">'React'</span>, </span><br><span class="line">    <span class="string">'333'</span>: <span class="string">'Webpack'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//call Id</span></span><br><span class="line"><span class="keyword">const</span> handleMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">//根据call Id找到对应的处理函数</span></span><br><span class="line">handleMap.set(<span class="string">'node_rpc_handle_fun_id_1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//做一些其他事情</span></span><br><span class="line">    <span class="keyword">return</span> data[key] || <span class="string">'404'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据处理</span></span><br><span class="line"><span class="keyword">const</span> messages = protobuf(fs.readFileSync(path.join(__dirname, <span class="string">'./test.proto'</span>), <span class="string">'utf-8'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">    socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//参数数据反序列化</span></span><br><span class="line">        <span class="keyword">const</span> data = messages.Test.decode(buffer);</span><br><span class="line">        <span class="keyword">const</span> fn = handleMap.get(data.handleId);</span><br><span class="line">        <span class="keyword">const</span> result = fn(data.key);</span><br><span class="line">        <span class="comment">//数据结果序列化</span></span><br><span class="line">        <span class="keyword">const</span> buf = messages.Resp.encode(&#123;</span><br><span class="line">            result,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//网络传输</span></span><br><span class="line">        socket.write(buf);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure>

<p>当<code>client</code>端向<code>server</code>端发起<code>RPC</code>调用时，我们注意到处理程序是在<code>server</code>运行的，然后将结果返回。<br>PS：<strong>这里的<code>client</code>和<code>server</code>并不一定是<code>NodeJS</code>,其他服务端语言都行。</strong></p>
<p>警告：<strong>上面的例子只能作为<code>Demo</code>用来理解<code>RPC</code>调用，业务中不能这么调用。如何处理网络错误，如何防止攻击，如何做流量控制，如何做数据切分，如何将请求和响应做一一对应等等。</strong></p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS·应用篇</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS是什么</title>
    <url>/2020/04/21/NodeJS%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="到底什么是NodeJS"><a href="#到底什么是NodeJS" class="headerlink" title="到底什么是NodeJS"></a>到底什么是NodeJS</h1><p>如果有人问你到底什么是node,可以用一句话来回答，因为这句话基本上包含了node的本质和其作用：<br><strong>Node不是一门语言，也不是一个框架，是基于Chrome V8引擎的JavaScript运行时环境；同时结合libuv扩展了JavaScript的功能，使得JavaScript能够支持浏览器Dom的操作，同时具有了后端语言才有的I/O，文件读写和操作数据库的能力，是目前最简单的全栈环境。</strong></p>
<p>作为前端程序员我们首先要知道为什么Node选择了JavaScript，因为：<strong>语言的语法结构简单，进行数据提取和分析就越容易，用来开发互联网应用也就越简单，如果对象创建和线程管理都不是必须的，那么基于原型而不是面向对象的JavaScript就是最完美的</strong>。</p>
<p>万维网之父Tim-Berners-Lee曾经说过：</p>
<blockquote>
<p>任何可以使用JavaScript实现的应用，最终都用JavaScript实现</p>
</blockquote>
<h1 id="NodeJS概述"><a href="#NodeJS概述" class="headerlink" title="NodeJS概述"></a>NodeJS概述</h1><p>在官网有段关于node的描述如下：</p>
<blockquote>
<p>Node.js is a JavaScript runtime built on Chrome’s V8 engine. Node.js uses an event-driven , non-block I/O model that makes it lightweight and efficient, Node.js’ package ecosystem,npm, is the largest ecosystem of open source libraries in the world</p>
</blockquote>
<ul>
<li>首先最重要的就是<code>NodeJS</code>的本质是<code>JavaScript</code>环境运行时，因为在过去<code>JavaScript</code>只能在浏览器当中运行，而因为浏览器当中有JS引擎，它可以帮助浏览器去识别和执行<code>JavaScript</code>语言，但是浏览器是每个不同厂家的产品，其实使用的引擎也不一样，而作为最近十年表现优异的V8引擎也帮助Chrome浏览器在市场独占鳌头，所以有人把它拿出来做了修改，让V8引擎可以单独运行在别的地方，也致使<code>JavaScript</code>脱离的浏览器也可以运行，所谓环境运行时，就是<code>JavaScript</code>可以运行的平台。</li>
<li><code>JavaScript</code>和<code>C++</code>有着千丝万缕的联系。因为V8引擎是通过C++来编写的，但是实际上这种底层语言的学习成本和使用成本都很大，我们编写的<code>JavaScript</code>实际上要转化成为这种<code>C++</code>去运行的，同时在<code>NodeJS</code>当中<code>I/O</code>都是异步的，全部要交给由<code>C++</code>编写的<code>libuv</code>这个事件循环库来处理，简化了并发模型。</li>
<li><code>NodeJS</code>的目标是让并发变的简单，而使用的这种<code>事件循环和非阻塞I/O模型</code>让在以网络编程为主的<code>I/O密集</code>的应用当中脱引而出。</li>
</ul>
<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>首先<code>I/O</code>是<code>input</code>和<code>output</code>的缩写，表示计算机输入输出的意思，除了常见的键盘，显示器，打印机都是输入输出设备，对计算机来说读写磁盘和网络操作都是<code>I/O操作</code>，当然数据库的操作也算，因为数据库也在磁盘当中。</p>
<p>我们先来看看<code>阻塞I/O</code>：<code>I/O</code>的时候进程休眠等待<code>I/O</code>完成后进入下一步。如果不考虑跳转语句，普通的程序是逐条执行的，当程序走到I/O操作的时候，程序会调用操作系统更底层的命令来完成操作，期间程序就会等待底层命令返回结果。拿到结果才能进行下一条程序语句的执行，我们把程序等待底层命令结果返回的这种行为或者现象称之为阻塞。</p>
<p><code>非阻塞I/O</code>：<code>I/O</code>时函数立即返回，进程不等待<code>I/O</code>完成。程序进行到<code>I/O操作</code>的时候，主程序开始调用底层命令，但是主程序并不会一直等待底层命令的返回，而是执行下一条程序语句。然后等到底层<code>I/O</code>有结果返回的时候，主程序再去决定丢弃还是处理。</p>
<p>但是计算机指令都可以理解为阻塞的，为什么偏偏<code>I/O操作</code>就是特殊的呢？简单来说: 大部分的指令都依赖于<code>CPU</code>运算，因为到当下来说<code>CPU</code>运行速度极其的快，一秒能执行30亿条语句，非<code>I/O操作</code>压根感觉不到阻塞，但是<code>I/O操作</code>更慢，比如拷贝电影文件，这都是肉眼看得见的慢。</p>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>前面我们说<code>I/O操作</code>完成后主程序会感知到，但是一定会有一种机制，就是主程序啥时候知道<code>I/O操作</code>完成，或者说完成的结果以怎么样的方式告诉主程序？</p>
<p><code>非阻塞的I/O</code>认为立即完成的，同时发射一个事件并写好这个事件的处理函数，底层I/O操作完成后触发这个事件并执行相关的处理函数，内部的实现实际上是一个<code>观察者模式</code><br><img src="/2020/04/21/NodeJS%E6%98%AF%E4%BB%80%E4%B9%88/1.jpg" alt="NodeJS事件驱动"></p>
<p>首先<code>libuv</code>由<code>事件循环</code>和<code>线程池</code>组成，负责所有<code>I/O任务</code>的分发和执行 Node.js是由事件循环来分发I/O任务，由工作线程将任务分发到线程池当中，事件循环只需要等待执行结果即可。这就是node的事件驱动模式。</p>
<ul>
<li>因为<code>JS</code>是单线程,单线程的特点就是同同一时间只能干一件事，所有任务都需要排队挨个执行。</li>
<li>当<code>CPU</code>空闲时，它完全可以不管<code>I/O设备</code>而直接挂起处于等待中的任务，先运行排在后面的任务。</li>
</ul>
<h2 id="NodeJS的特点"><a href="#NodeJS的特点" class="headerlink" title="NodeJS的特点"></a>NodeJS的特点</h2><p><code>NodeJS</code>的四个最大特点：<code>适合构建WEB应用</code>、<code>高性能</code>、 <code>简单</code>、 <code>可扩展</code></p>
<h3 id="适合构建WEB应用"><a href="#适合构建WEB应用" class="headerlink" title="适合构建WEB应用"></a>适合构建WEB应用</h3><p><code>WEB应用</code>基本都是<code>I/O密集</code>的场所，根据上面<code>NodeJS</code>的简单介绍，可以看出<code>NodeJS</code>是非常适合这种场景的。</p>
<h4 id="I-O密集-CPU密集"><a href="#I-O密集-CPU密集" class="headerlink" title="I/O密集 || CPU密集"></a>I/O密集 || CPU密集</h4><ul>
<li>CPU密集：程序大部分用来做计算和逻辑处理，比如牙所，解压，加密，解密等等。</li>
<li>I/O密集：程序大部分用来做存取设备，网络设施的一些读取操作，以及数据库的读取，比如文件操作，网络操作，数据库。</li>
</ul>
<h4 id="Web场景"><a href="#Web场景" class="headerlink" title="Web场景"></a>Web场景</h4><p>让我们想一下<code>Web</code>的常见场景</p>
<ul>
<li>静态资源读取：基本上网络当中静态资源的获取都是要从服务器上获取，服务器这些资源是放在服务器的硬盘上的，所以对于服务器就是静态资源读取，属于文件操作，属于I/O密集。</li>
<li>页面渲染：渲染页面也是取模板，也是属于I/O操作。</li>
</ul>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul>
<li>代码执行效率高：<code>NodeJS</code>构建在优秀的V8引擎上，执行速度在动态语言中算最快的。</li>
<li>天生异步：<code>事件驱动</code>和<code>非阻塞I/O</code>特性决定了必须要采用异步的方式，实际上每个<code>I/O</code>都是异步的，因此集成到<code>libuv</code>中才会让开发者感觉不到并发的存在。</li>
</ul>
<h3 id="简单可扩展"><a href="#简单可扩展" class="headerlink" title="简单可扩展"></a>简单可扩展</h3><p><code>NodeJS</code>的开发语言是<code>JavaScript</code>。作为前端工程师，<code>JavaScript</code>应该是我们最熟悉的语言，<code>JavaScript</code>的高度动态性使得<code>NodeJS</code>变得非常易于扩展。</p>
<h2 id="NodeJS的工作模式"><a href="#NodeJS的工作模式" class="headerlink" title="NodeJS的工作模式"></a>NodeJS的工作模式</h2><p>有关<code>事件循环</code>和<code>非阻塞I/O</code>我们这里依然有必有再说一下，这次我们将用最通俗的语言来讲，并且解释为什么这种模型能面对高并发。<br><img src="/2020/04/21/NodeJS%E6%98%AF%E4%BB%80%E4%B9%88/2.png" alt="NodeJS的工作模式"></p>
<h3 id="传统Apache工作流程"><a href="#传统Apache工作流程" class="headerlink" title="传统Apache工作流程"></a>传统Apache工作流程</h3><p>在此之前我们先说说传统的<code>java apache</code>是怎么工作的。<br>面对用户访问，它是每次一个用户访问进来就要开启一个进程，在这个进程中进行<code>CPU</code>对请求分析，然后再进行<code>I/O操作</code>。好比一个饭店是这样的工作模式，一个服务员配对一个大厨，这个服务员就是<code>CPU</code>,大厨就是<code>I/O</code>,他们属于一个进程里的东西，服务员点菜，然后交给同一个进程中的大厨去进行<code>I/O操作</code>。但是这个模式有两个特别明显的缺点：</p>
<ul>
<li>一个服务器最大进程数有限 ，比如最大可以开5000个进程，那就说明同时只能处理5000个用户访问，第5001个用户就得等着（这就好比饭店中有30个服务员和30个大厨，第30个客人来就要等，等到哪个大厨做完才能开始点菜。</li>
<li><code>CPU</code>被严重浪费 ，同时开5000个进程，一个进程完全处理一个请求需要10分钟，但是<code>CPU</code>处理的速度远远大于<code>I/O</code>,导致进程处于在<code>I/O</code>操作的时候，进程中分配的<code>CPU</code>是空闲的（好比服务员点菜需要一分钟，而大厨做菜需要30分钟，导致服务员在大厨做饭的时候没事干，玩手机）。</li>
</ul>
<h3 id="NodeJS的工作流程"><a href="#NodeJS的工作流程" class="headerlink" title="NodeJS的工作流程"></a>NodeJS的工作流程</h3><p>相比之下，我们上图中<code>NodeJS</code>的工作模型就完美的解决了问题，面对用户的访问，只开一个单线程，这个单线程当中处理所有用户的请求分析，但是所有<code>I/O的操作</code>都交个多线程去做，这种模型就好比一个饭店只招一个服务员，但是有很多大厨，服务员可以不停的点菜，大厨可以不停的做菜，而且做好了就告诉服务员，服务员按号码给顾客上菜即可，当然顺序也是不一定，谁的菜先好了就给谁。这样的模型就不会怕客人多，服务员也不会空闲。虽然大厨做菜的这个时间是没有办法缩短的，但是服务员的利用率提高了，也就是<code>CPU</code>利用率提高了，同时无论多少客人来都不会等待点菜，只会等待做菜。</p>
<p>PS：但是我们特别要注意的就是在上图这个模型中，事件循环（Event Lopp）是单线程的，也就是只开一个进程，这个进程里只有一个线程。而<code>非阻塞I/O</code>(Non-blocking)是多线程的，这里是操作系统在调度自己的多进程多进程，和<code>NodeJS</code>开启的单线程没啥关系。所以<code>Nodejs</code>当中的单线程只针对主进程，<code>I/O操作</code>系统底层是多线程调度。</p>
<p><strong>NodeJS的多线程</strong><br>在<code>NodeJS</code>当中有个<code>Cluster</code>的模块，专门解决多核并发问题，使用这个模块<code>CPU</code>有几个核我们就起几个进程。</p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS·基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS的模块机制</title>
    <url>/2020/04/22/NodeJS%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="如何理解NodeJS的模块"><a href="#如何理解NodeJS的模块" class="headerlink" title="如何理解NodeJS的模块"></a>如何理解NodeJS的模块</h2><h3 id="NodeJS模块的本质"><a href="#NodeJS模块的本质" class="headerlink" title="NodeJS模块的本质"></a>NodeJS模块的本质</h3><p>通过前面<code>CommonJS</code>的学习，我们对NodeJS有了一个初步的认识。<a href="https://wustcyl.github.io/2020/04/21/CommonJS%E8%A7%84%E8%8C%83/">CommonJS规范</a><br>我们先讨论模块在被引用之前到底<code>NodeJS</code>执行了什么操作。</p>
<p>其实每个模块在被引用的时候都被头尾包装，将其包裹在一个函数当中，代码执行完毕后将<code>exports</code>对象作为该函数的返回值返回给引用方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">exports,require,module,__firename,__dirname</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//模块中你自己书写的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是你平时可以直接使用<code>exports</code>、<code>require</code>、<code>module</code>、<code>__firename</code>、<code>__dirname</code>这个五个变量的原因.<br>我们都知道在<code>JS</code>中，最常见的就是通过函数来创建函数作用域。<br>对于每个模块（文件）来说，<code>NodeJS</code>想要做俩件事情。</p>
<ul>
<li>保证顶层的变量只在模块内部起作用(变量的作用域限制在本地而不会暴露到全局) </li>
<li>帮助提供一些全局查找的变量(上面五个)</li>
</ul>
<p>我们简单看一下源码如何实现的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code wrapper</span></span><br><span class="line">NativeModule.wrapper = [</span><br><span class="line">  <span class="string">'(function (exports,require,module,__firename,__dirname) &#123;'</span>,</span><br><span class="line">  <span class="string">'\n &#125;)'</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">//script为源代码</span></span><br><span class="line">NativeModule.warp = <span class="function"><span class="keyword">function</span> (<span class="params">script</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> NativeModule.wrapper[<span class="number">0</span>] + script + NativeModule.wrapper[<span class="number">1</span>]  <span class="comment">// 拼接字符串的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码编译</span></span><br><span class="line">NativeModule.prototype.compile = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> source = NativeModule.getSource(<span class="keyword">this</span>.id)       <span class="comment">// 这里的id指的就是模块的名称，同时也是文件的地址</span></span><br><span class="line">  source = NativeModule.warp(source)</span><br><span class="line">  <span class="keyword">this</span>.loading = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = runInThisContext(source, &#123;    <span class="comment">// 具体执行代码的方法是runInThisContext</span></span><br><span class="line">      fileName: <span class="keyword">this</span>.fileName,</span><br><span class="line">      lineOffset: <span class="number">0</span>,</span><br><span class="line">      disPlayErrors: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    fn(<span class="keyword">this</span>.exports,NativeModule.require,<span class="keyword">this</span>,<span class="keyword">this</span>.fileName)</span><br><span class="line">    <span class="keyword">this</span>.loaded = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> (error) &#123;</span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NodeJS模块的加载"><a href="#NodeJS模块的加载" class="headerlink" title="NodeJS模块的加载"></a>NodeJS模块的加载</h3><h4 id="module中到底有什么"><a href="#module中到底有什么" class="headerlink" title="module中到底有什么"></a>module中到底有什么</h4><p>我们创建一个<code>a.js</code>文件然后里面的内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module &#123;</span><br><span class="line">  id: <span class="string">'.'</span>,</span><br><span class="line">  exports: &#123;&#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">'C:\\Users\\Administrator\\Desktop\\fsDemo\\a.js'</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children: [],</span><br><span class="line">  paths:</span><br><span class="line">   [ <span class="string">'C:\\Users\\Administrator\\Desktop\\fsDemo\\node_modules'</span>,</span><br><span class="line">     <span class="string">'C:\\Users\\Administrator\\Desktop\\node_modules'</span>,</span><br><span class="line">     <span class="string">'C:\\Users\\Administrator\\node_modules'</span>,</span><br><span class="line">     <span class="string">'C:\\Users\\node_modules'</span>,</span><br><span class="line">     <span class="string">'C:\\node_modules'</span> ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续创建一个<code>b.js</code>文件，然后里面的内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module &#123;</span><br><span class="line">  id: <span class="string">'C:\\Users\\Administrator\\Desktop\\fsDemo\\a.js'</span>,</span><br><span class="line">  exports: &#123;&#125;,</span><br><span class="line">  parent:</span><br><span class="line">   Module &#123;</span><br><span class="line">     id: <span class="string">'.'</span>,</span><br><span class="line">     exports: &#123;&#125;,</span><br><span class="line">     parent: <span class="literal">null</span>,</span><br><span class="line">     filename: <span class="string">'C:\\Users\\Administrator\\Desktop\\fsDemo\\b.js'</span>,</span><br><span class="line">     loaded: <span class="literal">false</span>,</span><br><span class="line">     children: [ [Circular] ],</span><br><span class="line">     paths:</span><br><span class="line">      [ <span class="string">'C:\\Users\\Administrator\\Desktop\\fsDemo\\node_modules'</span>,</span><br><span class="line">        <span class="string">'C:\\Users\\Administrator\\Desktop\\node_modules'</span>,</span><br><span class="line">        <span class="string">'C:\\Users\\Administrator\\node_modules'</span>,</span><br><span class="line">        <span class="string">'C:\\Users\\node_modules'</span>,</span><br><span class="line">        <span class="string">'C:\\node_modules'</span> ] &#125;,</span><br><span class="line">  filename: <span class="string">'C:\\Users\\Administrator\\Desktop\\fsDemo\\a.js'</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children: [],</span><br><span class="line">  paths:</span><br><span class="line">   [ <span class="string">'C:\\Users\\Administrator\\Desktop\\fsDemo\\node_modules'</span>,</span><br><span class="line">     <span class="string">'C:\\Users\\Administrator\\Desktop\\node_modules'</span>,</span><br><span class="line">     <span class="string">'C:\\Users\\Administrator\\node_modules'</span>,</span><br><span class="line">     <span class="string">'C:\\Users\\node_modules'</span>,</span><br><span class="line">     <span class="string">'C:\\node_modules'</span> ] &#125;</span><br></pre></td></tr></table></figure>
<p>引用一个模块是按照paths属性当中的数组一层层的遍历寻找。</p>
<p>现在，我们可以简单的通过一个构造函数来表示一个模块的定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id,parent</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id</span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent</span><br><span class="line">    updateChileren(parent,<span class="keyword">this</span>,<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">this</span>.fileName = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.loaded = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.children = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以模块在被包装的时候所传递的<code>module</code>参数就是模块本身，而模块本身不包含你在这个文件所写的代码的，模块执行的时候是根据模块id来读取的你编写的代码的，然后拼接好成为字符串，依靠V8底层的C++代码来识别和执行整个字符串的。</p>
<h3 id="模块的查找"><a href="#模块的查找" class="headerlink" title="模块的查找"></a>模块的查找</h3><p><code>NodeJS</code>当中的模块有两种类型，<code>核心模块</code> 和 <code>文件模块</code>，通过<code>require</code>方法能引用的就是这两种模块，只不过参数的类型还是比较丰富：</p>
<ul>
<li><code>http,fs,path</code>等<code>NodeJS</code>内置的核心模块</li>
<li><code>./mod</code>或者<code>../mod</code>等这种相对路径的文件模块</li>
<li><code>/pathtomodule/mod</code>等这种绝对路径的文件模块</li>
<li>核心模块的优先级最高，在有命名冲突的情况下优先加载核心模块，文件模块只能按照相对路径和绝对路径的方式去加载</li>
<li>第三方模块加载</li>
</ul>
<p>这里我们说一下第三方模块的加载步骤：<br>首先在当前目录下的<code>node_module</code>目录下面查找是否包含这样一个模块，如果没有找到，就要在当前目录的上一层<code>node_module</code>目录中继续查找，反复执行直到根目录为止。<br>由于<code>Node.js</code>中存在4类模块（原生模块和3种文件模块），尽管<code>require</code>方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：<br><img src="/2020/04/22/NodeJS%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/1.png" alt="NodeJS模块加载流程图"></p>
<h4 id="初查阶段"><a href="#初查阶段" class="headerlink" title="初查阶段"></a>初查阶段</h4><ul>
<li>如果是node核心模块，就直接返回模块名称</li>
<li>如果是引入的第三方npm模块，会返回父级所在文件夹下的node_modules，父父级所在文件夹下的node_modules，依次递归，一直到/node_modules和用户名下的.node_modules以及全局环境变量配置的全局安装的模块文件夹组成的数组</li>
<li>如果是相对路径引入的模块，会将相对路径和父级路径之间进行一个path.resolve()，然后返回</li>
</ul>
<h4 id="精确查找，获取文件绝对路径"><a href="#精确查找，获取文件绝对路径" class="headerlink" title="精确查找，获取文件绝对路径"></a>精确查找，获取文件绝对路径</h4><ul>
<li>先尝试加载node_modules/express，这种没有扩展名的文件是否存在</li>
<li>尝试按照扩展名规则查找，依次判断node_modules文件夹下.js .json .node结尾的文件名为express的文件是否存在，返回文件的绝对路径</li>
<li>判断node_modules/express文件夹下的package.json是否存在，如果存在，返回main字段指定的文件的绝对路径</li>
<li>判断node_modules/express/index.js是否存在，存在返回对应文件绝对路径</li>
</ul>
<p>我们初略看一下<code>NodeJS</code>的加载模块源代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(parent) &#123;</span><br><span class="line">    debug(<span class="string">'Module._load REQUEST %s parent: %s'</span>,request,parent.id)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取文件路径</span></span><br><span class="line">  <span class="keyword">var</span> filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line">  <span class="comment">// 尝试从缓存中读取模块</span></span><br><span class="line">  <span class="keyword">var</span> cachedModule = Module._cache[filename];</span><br><span class="line">  <span class="keyword">if</span> (cachedModule) &#123;</span><br><span class="line">    updateChildren(parent, cachedModule, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 如果是原生模块返回</span></span><br><span class="line">  <span class="keyword">if</span> (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">    debug(<span class="string">'load native module %s'</span>, request);</span><br><span class="line">    <span class="keyword">return</span> NativeModule.require(filename);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第三方模块创建模块对象</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMain) &#123;</span><br><span class="line">    process.mainModule = <span class="built_in">module</span>;</span><br><span class="line">    <span class="built_in">module</span>.id = <span class="string">'.'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 缓存模块</span></span><br><span class="line">  Module._cache[filename] = <span class="built_in">module</span>;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 加载模块</span></span><br><span class="line">  tryModuleLoad(<span class="built_in">module</span>, filename);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 返回模块的exports</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这个源码是Node加载模块直接会调用的函数，但是在里面很多其他的函数我们需要单独拿出来理解，但是单独拿出来讲会让你理解的思路不清晰，所以我们这里给出一幅图，让你清楚的看到每个函数到底在干什么：<strong>加载模块是从require函数开始的，require函数当中返回的是Module._load函数结果，所以我们从Module._load入手看看整个加载过程是怎么样的</strong><br><img src="/2020/04/22/NodeJS%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/2.png" alt="Module._load"></p>
<p><code>NodeJS</code>加载模块的情况大致就是这样了。</p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS·基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS的性能优化一</title>
    <url>/2020/05/22/NodeJS%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/</url>
    <content><![CDATA[<p>通过<code>NodeJS</code>构建前后端BFF层时，<code>NodeJS</code>的性能常常会变成瓶颈，所以性能分析是非常重要。<br>利用koa构建一个简单的http服务器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> mount = <span class="built_in">require</span>(<span class="string">'koa-mount'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(mount(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = fs.readFileSync(path.join(__dirname, <span class="string">'./index.html'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`http://localhost:3000`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="http服务器性能分析"><a href="#http服务器性能分析" class="headerlink" title="http服务器性能分析"></a>http服务器性能分析</h3><p>常用的<code>http</code>服务器性能一般是进行压力测试，常用的压力测试工具一般有: <code>Apache ab</code>, <code>webbench</code>.<br>以<code>ab</code>为例<br>Ab命令参数注释：</p>
<p>　　-n    #指定在测试会话中所执行的请求个数。默认时，仅执行一个请求。　</p>
<p>　　-c    #指定一次产生的请求个数。默认是一次一个。</p>
<p>　　-t    #测试所进行的最大秒数。其内部隐含值是-n 50000。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。</p>
<p>　　-p    #包含了需要POST的数据的文件.</p>
<p>　　-T    #POST数据所使用的Content-type头信息。</p>
<p>　　-v    #设置显示信息的详细程度 - 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。</p>
<p>　　-w    #以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。</p>
<p>　　-I    #执行HEAD请求，而不是GET。</p>
<p>执行以下测试命令：<code>ab -c200 -n1600 http://localhost:3000</code>，之后会得到一份分析报告 如图所示：<br><img src="/2020/05/22/NodeJS%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/1.png" alt="分析报告"><br>其中最重要的是<code>requests pre second(QPS)</code>, <code>transfer rate(传输速率)</code>。</p>
<h3 id="NodeJS性能分析工具"><a href="#NodeJS性能分析工具" class="headerlink" title="NodeJS性能分析工具"></a>NodeJS性能分析工具</h3><p>通过<code>NodeJS</code>性能分析工具可以分析出代码在那个地方消耗的性能最多, 然后进行性能优化。<br>大体上有三个方法：</p>
<ul>
<li>利用<code>NodeJS</code>本身自带的<code>profile</code></li>
<li>利用<code>chrome</code>的<code>devtool</code></li>
<li><code>clinic.js</code></li>
</ul>
<h4 id="利用profile进行性能测试"><a href="#利用profile进行性能测试" class="headerlink" title="利用profile进行性能测试"></a>利用profile进行性能测试</h4><p>首先将<code>Node</code>的启动命令上加入<code>--prof</code>, <code>node --prof path</code>（此时会生成一个log文件）<br>然后通过<code>ab</code>进行压力测试，等到测试完成结束后，执行<code>node --prof-process ${log文件路径} &gt; ${保存数据文件名}.txt</code></p>
<p>其中数据最重要的就是<code>bottom up</code><br><img src="/2020/05/22/NodeJS%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/2.png" alt="分析报告"><br>它展示了整个调用栈，而且耗时比例也展示的非常清楚，比如第一行展示耗时占整个的20%，下一行占上一行的100%，以此类推。</p>
<h4 id="利用devtool进行性能测试"><a href="#利用devtool进行性能测试" class="headerlink" title="利用devtool进行性能测试"></a>利用devtool进行性能测试</h4><p>首先将<code>Node</code>的启动命令上加入<code>--inspect-brk</code>, <code>node --inspect-brk path</code>。在<code>chrome</code>浏览器上面输入<code>chrome://inspect</code><br>在<code>romote target</code>中进入调试代码，然后进行压力测试，观察<code>profiler</code><br><img src="/2020/05/22/NodeJS%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/3.png" alt="分析报告">, 该数据和利用<code>profile</code>得到数据类似。</p>
<h4 id="利用clinic进行性能测试"><a href="#利用clinic进行性能测试" class="headerlink" title="利用clinic进行性能测试"></a>利用clinic进行性能测试</h4><p><a href="https://www.npmjs.com/package/clinic" target="_blank" rel="noopener">clinic</a></p>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>从上面的性能优化分析报告，我们可以得到性能优化的位置。<br><img src="/2020/05/22/NodeJS%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/4.png" alt="分析报告">，不难发现消耗第一个大头是这个<code>readFileSync</code>函数。<br>对于每一次访问都读取其实非常不明智的，因为很明显读取的结果可以通过一个变量存起来的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = fs.readFileSync(path.join(__dirname, <span class="string">'./index.html'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">app.use(mount(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = str;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/22/NodeJS%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/5.png" alt="分析报告"><br>分析得出，还有一个求<code>byteLength</code>函数也消耗非常多性能，这是因为<code>NodeJS</code>的底层是使用的<code>C++</code>,<code>C++</code>处理时首先的转换成<code>buffer</code>所以这里耗费一些时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = fs.readFileSync(path.join(__dirname, <span class="string">'./index.html'</span>));</span><br><span class="line"></span><br><span class="line">app.use(mount(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    ctx.status = <span class="number">200</span>;</span><br><span class="line">    ctx.type = <span class="string">'text/html'</span></span><br><span class="line">    ctx.body = buffer;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>重新进行压力测试。<br><img src="/2020/05/22/NodeJS%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/6.png" alt="分析报告"></p>
<p>非常清楚的可以看到<code>requests pre second(QPS)</code>, <code>transfer rate(传输速率)</code>大幅度提示了。</p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS·应用篇</tag>
      </tags>
  </entry>
  <entry>
    <title>开启你的NodeJS之旅</title>
    <url>/2020/04/21/%E5%BC%80%E5%90%AF%E4%BD%A0%E7%9A%84NodeJS%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h1 id="一句话概述NodeJS"><a href="#一句话概述NodeJS" class="headerlink" title="一句话概述NodeJS"></a>一句话概述NodeJS</h1><p><code>Node.js</code>是一个能够在服务器端运行<code>JavaScript</code>的开放源代码、跨平台<code>JavaScript</code>运行环境。</p>
<h1 id="NodeJS的特点"><a href="#NodeJS的特点" class="headerlink" title="NodeJS的特点"></a>NodeJS的特点</h1><p><code>Node.js</code>采用Google开发的V8运行代码，使用<code>事件驱动</code>、<code>非阻塞IO</code>模型等技术来提高性能，可优化应用程序的传输量和规模,这些技术通常用于数据密集的即时应用程序。</p>
<h1 id="为什么要学NodeJS"><a href="#为什么要学NodeJS" class="headerlink" title="为什么要学NodeJS"></a>为什么要学NodeJS</h1><p>现在对于前端工程师来说，<code>NodeJS</code>已经成为了必备的一项技能。</p>
<ul>
<li>可以通过<code>NodeJS</code>来构建<code>BFF</code>层和后端进行<code>rpc</code>调用，为前端提供<code>http</code>服务，常见的比如就是<code>SSR</code>(服务端渲染）。</li>
<li>可以构建前端需要的工作流如<code>Gulp</code>, <code>Webpack</code>。</li>
<li>可以构建开发者工具如<code>VS Code</code>。</li>
<li>可以构建客户端应用如<code>Electron</code>, 使用<code>NodeJS</code>构建的项目可以最大限度的复用目前的Web工程。</li>
</ul>
<h1 id="NodeJS的安装"><a href="#NodeJS的安装" class="headerlink" title="NodeJS的安装"></a>NodeJS的安装</h1><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJS官网</a></p>
<h1 id="NodeJS的面试题目"><a href="#NodeJS的面试题目" class="headerlink" title="NodeJS的面试题目"></a>NodeJS的面试题目</h1><p>希望你在学习完Node后也不妨来试试下面这些面试题，思考面试题的目的不是为了记忆，而是从各个角度来检测自己关于知识体系的漏洞。因为很多时候，所谓面试题的答案并不是最佳的理解，因为最佳的理解只来自于自己深刻理解知识点并熟练运用后的体会。</p>
<ul>
<li><a href="https://juejin.im/post/5d2fc598e51d4577596487a3" target="_blank" rel="noopener">NodeJS有难度的面试题，你能答对几个？</a></li>
<li><a href="https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn" target="_blank" rel="noopener">如何通过饿了么 Node.js 面试</a></li>
<li><a href="https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn" target="_blank" rel="noopener">Node.js面试题之2017</a></li>
</ul>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS·基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title>使用NodeJS创建一个GraphQL服务器</title>
    <url>/2020/05/12/%E4%BD%BF%E7%94%A8NodeJS%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAGraphQL%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/5c015a5af265da612577d89a#heading-0" target="_blank" rel="noopener">译 使用 NodeJS 创建一个 GraphQL 服务器</a></p>
<p><a href="https://graphql.cn/code/#javascript" target="_blank" rel="noopener">GraphQL与JavaScript</a></p>
<p><a href="https://www.apollographql.com/docs/apollo-server/" target="_blank" rel="noopener">apollo-server</a></p>
<p>Express中间件 <code>apollo-server-express</code><br>Koa中间件 <code>apollo-server-koa</code></p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS·应用篇</tag>
      </tags>
  </entry>
</search>
